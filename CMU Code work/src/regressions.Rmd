---
title: "Undergrad research"
authors: "Alvin Pan"
Andrew IDs: "qpan"
output:
  pdf_document:
    toc: no
  html_document:
    toc: true
    toc_float: true
    theme: spacelab
---

---------import library packages and datasets

```{r}
library("readxl")
library(tidyverse)
library(np)
library(GauPro)
library("GPfit")
library("lhs")
```



---------Function interfaces


```{r}
# extract top n states with the most people
top_pop_states <- function(data, n=5) {
  d = data %>% group_by(STATE) %>% summarize(POPULATION = mean(POPULATION, na.rm = TRUE))
  return (top_n(d, n=n, wt=POPULATION)[[1]])                          
}
```


```{r}
# plot covid cases for top population states
plot_states <- function(data, states, feature, x=1, y=1) {
  # top_states = top_pop_states(covid, n)
  par(mfrow=c(x,y), mar=c(4,4,2,0.5)) # Setup grid, margins
  for (state in states) {
    d = data %>% filter(STATE == state)
    plot(d$DATE, d[,feature], xlab = "Time", ylab = feature, main = paste("COVID cases in", state), pch = 20, cex = 0.5)
  }
}
```



```{r}
# This function outputs the corresponding optimal parameter given the regression method: spline, kernel or GP
calc_opt_para <- function(data, state, feature, dates, method="spline") {
  n = dim(data)[1]
  m = n%%5
  err.mat = matrix(rep(0, 5*50), ncol = 5)
  
  if (m == 0) {
    samp = sample(rep(1:5, n%/%5), replace = FALSE)
  } else {
    samp = sample(c(rep(1:5, n%/%5),1:m), replace = FALSE)
  }
  
  
  if (method == "spline") {
    dfs = 2:51
    for (df in dfs) {
      for (k in 1:5) {
        testd <- data[samp == k, ] 
        traind <- data[!(samp == k), ]
        train.rows = nrow(traind)
        sm = smooth.spline(traind[,feature]~dates[!(samp == k)], df=df)
        sm.pred = predict(sm, dates[samp == k])$y
        err.mat[df-1,k] = mean((sm.pred-testd[,feature])^2)
      }
    }
    df.err.means = apply(err.mat, 1, mean)
    best.df = dfs[which.min(df.err.means)]
    
    return(best.df)
    
  } else { #kernel regression
    bs = 2:51
    for (b in bs) {
      for (k in 1:5) {
        testd <- data[samp == k, ] 
        traind <- data[!(samp == k), ]
        train.rows = nrow(traind)
        gm = npreg(dates[!(samp == k)], traind[,feature], bws = b)
        gm.pred = predict(gm, newdata=dates[samp == k])
        err.mat[b-1,k] = mean((gm.pred-testd[,feature])^2)
      }
    }
    bws.err.means = apply(err.mat, 1, mean)
    print(bws.err.means)
    best.bw = bs[which.min(bws.err.means)]
    
    
    return(best.bw)
  }
}
```


```{r}
# This function plots the optimal regression curves given the method and a vector of target states. 
plot_smooth_func <- function(data, states, feature, method="spline", x=1, y=3, df=20, bws=10) {
  # top_states = top_pop_states(covid, n)
  par(mfrow=c(x,y), mar=c(4,4,2,0.5)) # Setup grid, margins
  data = subset(data, !is.na(DATE) & !is.na(data[, feature]))
  if (method == "spline") {
    for (state in states) {
      d = data %>% filter(STATE == state)
      dates = as.numeric(d$DATE)
      plot(d$DATE, d[,feature], xlab = "Time", ylab = feature, main = paste("COVID cases in", state), pch = 20, cex = 0.5)
      if (is.null(df)) {
        df = calc_opt_para(d, state, feature, dates, method)
        #print(paste(c("The best spline df for", state, "is", as.character(df)), collapse=" "))
      }
      sm = smooth.spline(d[,feature]~dates, df=df)
      sm.pred = predict(sm, dates)$y
      lines(d$DATE, sm.pred, pch = 20, cex = 0.5, col = 3)
      cat(sprintf("The best spline df for %s is %d\n", state, df))
    }
  } else if (method == "gp") {
    for (state in states) {
      d = data %>% filter(STATE == state)
      dates = as.numeric(d$DATE)
      dates = (dates-min(dates))/(max(dates)-min(dates))
      #kern <- Matern52$new(0)
      #trend.0 <- trend_0$new()
      #gpk.exp <- GauPro_kernel_model$new(matrix(dates, ncol=1), d[,feature], kernel=kern, parallel=FALSE)
      #if (requireNamespace("MASS", quietly = TRUE)) {
      #  plot(gpk.exp)
      #  axis(1, at=dates, labels=d$DATE)
      #}
      n = length(dates)
      x <- matrix(dates, nrow=n)
      y <- matrix(as.vector(d[,feature]), nrow=n)
      
      GPmodel <- GP_fit(x, y)
    }
  } else { #kernel regression
    for (state in states) {
      d = data %>% filter(STATE == state)
      dates = as.numeric(d$DATE)
      plot(d$DATE, d[,feature], xlab = "Time", ylab = feature, main = paste("COVID cases in", state), pch = 20, cex = 0.5)
      if (is.null(bws)) {
        bws = calc_opt_para(d, state, feature, dates, method)
        print(paste(c("The best kernel bw for", state, "is", as.character(bws)), collapse=" "))
      }
      gm = npreg(dates, d[,feature], bws = bws)
      gm.pred = predict(gm, newdata=dates)
      lines(d$DATE, gm.pred, pch = 20, cex = 0.5, col = 5)
    }
  }
}
```


---------Function Implementations and Experiments

```{r}
covid.com = data.frame(read.csv("../data/covid.com.csv"))
covid.com$DATE = as.Date(covid.com$DATE)
```



```{r}
states = top_pop_states(covid)
plot_states(covid.com, c("FLORIDA"), 'NEWCD_NORM_500')
```

```{r}
plot_smooth_func(covid.com, c("PENNSYLVANIA", "WASHINGTON"), 'NEWCD_NORM_500', method="spline",x=1,y=2,df=NULL,bws=16)
```


```{r}
plot_smooth_func(covid.com, c("PENNSYLVANIA", "WASHINGTON", "CALIFORNIA"), 'NEWCD_NORM_500', method="kernel",x=1,y=2,df=20,bws=NULL)
```

```{r}
plot_smooth_func(covid.com, c("PENNSYLVANIA", "WASHINGTON", "CALIFORNIA"), 'NEWCD_NORM_500', method="gp",x=1,y=2,df=20,bws=7)
```



